using System;
using System.Collections.Generic;
using Azure.DataGateway.Service.Models;

namespace Azure.DataGateway.Service.Resolvers
{
    /// <summary>
    /// Wraps all the required data and logic to write a SQL INSERT query
    /// </summary>
    public class SqlInsertStructure : BaseSqlQueryStructure
    {
        /// <summary>
        /// Column names to insert into the given columns
        /// </summary>
        public List<string> InsertColumns { get; }

        /// <summary>
        /// Values to insert into the given columns
        /// </summary>
        public List<string> Values { get; }

        /// <summary>
        /// The inserted columns that the insert will return
        /// </summary>
        public List<string> ReturnColumns { get; }

        private readonly TableDefinition _tableDefinition;

        public SqlInsertStructure(string tableName, TableDefinition tableDefinition, IDictionary<string, object> mutationParams)
        : base()
        {
            TableName = tableName;
            InsertColumns = new();
            Values = new();

            _tableDefinition = tableDefinition;
            ReturnColumns = _tableDefinition.PrimaryKey;

            foreach (KeyValuePair<string, object> param in mutationParams)
            {
                if (param.Value == null)
                {
                    continue;
                }

                PopulateColumnsAndParams(param.Key, param.Value);
            }

            // If none of the column values were specified as one of the params,
            // we need to explicitly add. This scenario is possible for REST request.
            if (Columns.Count == 0)
            {
                List<string> allColumns = new(tableDefinition.Columns.Keys);

                // The assumption here is primary key columns need not be specified
                // since their value will be autogenerated.
                // More columns can be excluded if the metadata provides us information
                // that they have default values.
                IEnumerable<string> columnsToBeAdded = allColumns.Except(tableDefinition.PrimaryKey);
                foreach (string column in columnsToBeAdded)
                {
                    // Using null as the default value.
                    PopulateColumnsAndParams(column, value: null);
                }
            }

            // return primary key so the inserted row can be identified
            ReturnColumns = _tableDefinition.PrimaryKey.Select(primaryKey => QuoteIdentifier(primaryKey)).ToList();
        }

        /// <summary>
        /// Populates the column name in Columns, creates parameter
        /// and adds its value to Values.
        /// </summary>
        /// <param name="columnName">The name of the column.</param>
        /// <param name="value">The value of the column.</param>
        private void PopulateColumnsAndParams(string columnName, object value)
        {
            Columns.Add(QuoteIdentifier(columnName));
            string paramName;
            if (value != null)
            {
                paramName = MakeParamWithValue(
                    GetParamAsColumnSystemType(value.ToString(), columnName));
            }
            else
            {
                paramName = MakeParamWithValue(value: null);
            }

            Values.Add($"@{paramName}");

        }

        /// <summary>
        ///  Adds parameter to Parameters and returns the name associated with it
        /// </summary>
        /// <param name="value">The value of the parameter to be made.</param>
        private string MakeParamWithValue(object value)
        {
            string paramName = $"param{Counter.Next()}";
            Parameters.Add(paramName, value);
            return paramName;
        }

        ///<summary>
        /// Gets the value of the parameter cast as the type of the column this parameter is associated with
        ///</summary>
        /// <exception cref="ArgumentException">columnName is not a valid column of table or param does not have a valid value type</exception>
        public object GetParamAsColumnSystemType(string param, string columnName)
        {
            ColumnType type = GetColumnType(columnName);
            Type systemType = ColumnDefinition.ResolveColumnToSystemType(type);

            try
            {
                switch (systemType.Name)
                {
                    case "String":
                        return param;
                    case "Int64":
                        return long.Parse(param);
                    default:
                        // should never happen due to the config being validated for correct types
                        return null;
                }
            }
            catch (Exception e)
            {
                if (e is FormatException ||
                    e is ArgumentNullException ||
                    e is OverflowException)
                {
                    throw new ArgumentException($"Parameter \"{param}\" cannot be resolved as column \"{columnName}\" with type \"{type}\".");
                }

                throw;
            }
        }

        /// <summary>
        /// Gets column type from table underlying the insert strucutre
        /// </summary>
        public ColumnType GetColumnType(string columnName)
        {
            ColumnDefinition column;
            if (_tableDefinition.Columns.TryGetValue(columnName, out column))
            {
                return column.Type;
            }
            else
            {
                throw new ArgumentException($"{columnName} is not a valid column of {TableName}");
            }
        }
    }
}
