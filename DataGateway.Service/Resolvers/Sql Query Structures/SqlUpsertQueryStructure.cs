using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Azure.DataGateway.Service.Exceptions;
using Azure.DataGateway.Service.Models;
using Azure.DataGateway.Services;

namespace Azure.DataGateway.Service.Resolvers
{
    ///<summary>
    /// Wraps all the required data and logic to write a SQL UPDATE query
    ///</summary>
    public class SqlUpsertQueryStructure : BaseSqlQueryStructure
    {
        /// <summary>
        /// Column names to insert into the given columns
        /// </summary>
        public List<string> InsertColumns { get; }

        /// <summary>
        /// Values to insert into the given columns
        /// </summary>
        public List<string> Values { get; }

        /// <summary>
        /// Updates to be applied to selected row
        /// </summary>
        public List<Predicate> UpdateOperations { get; }

        /// <summary>
        /// The updated columns that the update will return
        /// </summary>
        public List<string> ReturnColumns { get; }

        /// <summary>
        /// An upsert query must be prepared to be utilized for either an UPDATE or INSERT.
        /// 
        /// </summary>
        /// <param name="tableName"></param>
        /// <param name="metadataStore"></param>
        /// <param name="mutationParams"></param>
        /// <exception cref="DatagatewayException"></exception>
        public SqlUpsertQueryStructure(string tableName, IMetadataStoreProvider metadataStore, IDictionary<string, object> mutationParams)
        : base(metadataStore)
        {
            TableName = tableName;
            UpdateOperations = new();
            InsertColumns = new();
            Values = new();

            TableDefinition tableDefinition = GetTableDefinition();

            //All columns will be returned whether upsert results in UPDATE or INSERT
            ReturnColumns = tableDefinition.Columns.Keys.ToList();

            //Populates the UpsertQueryStructure with UPDATE and INSERT column:value metadata
            PopulateColumns(mutationParams, tableDefinition);

            if (UpdateOperations.Count == 0)
            {
                throw new DatagatewayException("Update mutation does not update any values", 400, DatagatewayException.SubStatusCodes.BadRequest);
            }
        }

        private void PopulateColumns(
            IDictionary<string, object> mutationParams,
            TableDefinition tableDefinition)
        {
            List<string> primaryKeys = tableDefinition.PrimaryKey;
            List<string> schemaColumns = tableDefinition.Columns.Keys.ToList();

            foreach (KeyValuePair<string, object> param in mutationParams)
            {
                //User supplied parameters can be null unless PRIMARY KEY or nonNullable field-> this should
                //be covered by the request validator though. 
                // if (param.Value == null)
                //{
                //Insert doesn't use predicates, so we can not use them here.
                //don't need to add the param column name to insert, since it will take default value
                //and if NOT NULLABLE, then we'd receive a db error anyway. (do we want to throw
                //exception here instead of allowing a database call to proceed/further processing?

                //Update will accept a null, as it will overwrite the existing column value.
                // if column is not nullable, then we fail. 

                //we are guaranteed that a PK field will not be null.
                //so this would be a null value on a column to update
                //continue;
                //}

                //Create Parameter and mapping to column for downstream logic to utilize.
                string paramIdentifier = MakeParamWithValue(GetParamAsColumnSystemType(param.Value.ToString(), param.Key));
                ColumnToParam.Add(param.Key, paramIdentifier);

                //create a predicate for UPDATE Operations.
                Predicate predicate = new(
                    new PredicateOperand(new Column(null, param.Key)),
                    PredicateOperation.Equal,
                    new PredicateOperand($"@{paramIdentifier}")
                );

                //We are guaranteed by the RequestValidator, that a primary key column is in the URL, not body.
                // that means we must add the PK as predicate for the update request.
                // (where clause defining item by PK)
                if (primaryKeys.Contains(param.Key))
                {
                    //for update we don't care if it's autogenerated, we will update item based on PK.
                    if(!tableDefinition.Columns[param.Key].IsAutoGenerated)
                    {
                        //Only add PK column to insert request if not a PK.
                        InsertColumns.Add(param.Key);
                        PopulateColumnsAndParams(param.Key, param.Value);
                    }

                    //PK added as predicate for Update Operation
                    Predicates.Add(predicate);
                    //UpdateOperations.Add(predicate);

                    //Track which columns we've acted upon,
                    //so we can add nullified remainder columns later.
                    schemaColumns.Remove(param.Key);
                }
                // This mutation param is not a PK, just add update opeartion param.
                // No final else statement as invalid column for schema is caught in RequestValidation.
                else if (schemaColumns.Contains(param.Key))
                {
                    UpdateOperations.Add(predicate);
                    schemaColumns.Remove(param.Key);

                    //Insert Operation
                    //InsertColumns.Add(param.Key);
                    PopulateColumnsAndParams(param.Key, param.Value);
                }
            }

            //For remaining columns in schemaColumns, add them to update(overwrite) as null update operations.
            AddNullifiedUnspecifiedFields(schemaColumns);
        }

        /// <summary>
        /// For UPDATE (OVERWRITE) operation
        /// Adds result of (TableDefinition.Columns - MutationFields) to UpdateOperations with null values
        /// There will not be any columns leftover that are PK, since they are handled in calling method.
        /// </summary>
        /// <param name="columns"></param>
        private void AddNullifiedUnspecifiedFields(List<string> leftoverSchemaColumns)
        {
            //result of adding (TableDefinition.Columns - MutationFields) to UpdateOperations
            foreach (string leftOverColumn in leftoverSchemaColumns)
            {
                //TABLE alias for Column(tableAlias:<val>,columnName:<val>) as null could cause bug? 
                Predicate predicate = new(
                    new PredicateOperand(new Column(null, leftOverColumn)),
                    PredicateOperation.Equal,
                    new PredicateOperand($"@{MakeParamWithValue(null)}")
                );

                UpdateOperations.Add(predicate);
            }
        }

        /// <summary>
        /// Populates the column name in Columns, creates parameter
        /// and adds its value to Values.
        /// </summary>
        /// <param name="columnName">The name of the column.</param>
        /// <param name="value">The value of the column.</param>
        private void PopulateColumnsAndParams(string columnName, object value)
        {
            InsertColumns.Add(columnName);
            string paramName;

            try
            {
                if (value != null)
                {
                    //Check parameter Dictionary/List
                    paramName = ColumnToParam[columnName];
                }
                else
                {
                    // This case should not arise. We have issue for this to handle nullable type columns. Issue #146.
                    throw new DatagatewayException(
                        message: $"Unexpected value for column \"{columnName}\" provided.",
                        statusCode: (int)HttpStatusCode.BadRequest,
                        subStatusCode: DatagatewayException.SubStatusCodes.BadRequest);
                }

                Values.Add($"@{paramName}");
            }
            catch (ArgumentException ex)
            {
                throw new DatagatewayException(
                    message: ex.Message,
                    statusCode: (int)HttpStatusCode.BadRequest,
                    subStatusCode: DatagatewayException.SubStatusCodes.BadRequest);
            }
        }
    }
}
