using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Azure.DataGateway.Service.Exceptions;
using Azure.DataGateway.Service.Models;
using Azure.DataGateway.Services;

namespace Azure.DataGateway.Service.Resolvers
{
    ///<summary>
    /// Wraps all the required data and logic to write a SQL UPDATE query
    ///</summary>
    public class SqlUpsertQueryStructure : BaseSqlQueryStructure
    {
        /// <summary>
        /// Column names to insert into the given columns
        /// </summary>
        public List<string> InsertColumns { get; }

        /// <summary>
        /// Values to insert into the given columns
        /// </summary>
        public List<string> Values { get; }

        /// <summary>
        /// Updates to be applied to selected row
        /// </summary>
        public List<Predicate> UpdateOperations { get; }

        /// <summary>
        /// The updated columns that the update will return
        /// </summary>
        public List<string> ReturnColumns { get; }

        /// <summary>
        /// An upsert query must be prepared to be utilized for either an UPDATE or INSERT.
        /// 
        /// </summary>
        /// <param name="tableName"></param>
        /// <param name="metadataStore"></param>
        /// <param name="mutationParams"></param>
        /// <exception cref="DatagatewayException"></exception>
        public SqlUpsertQueryStructure(string tableName, IMetadataStoreProvider metadataStore, IDictionary<string, object> mutationParams)
        : base(metadataStore)
        {
            TableName = tableName;
            UpdateOperations = new();
            InsertColumns = new();
            Values = new();

            TableDefinition tableDefinition = GetTableDefinition();

            // All columns will be returned whether upsert results in UPDATE or INSERT
            ReturnColumns = tableDefinition.Columns.Keys.ToList();

            // Populates the UpsertQueryStructure with UPDATE and INSERT column:value metadata
            PopulateColumns(mutationParams, tableDefinition);

            if (UpdateOperations.Count == 0)
            {
                throw new DatagatewayException("Update mutation does not update any values", 400, DatagatewayException.SubStatusCodes.BadRequest);
            }
        }

        private void PopulateColumns(
            IDictionary<string, object> mutationParams,
            TableDefinition tableDefinition)
        {
            List<string> primaryKeys = tableDefinition.PrimaryKey;
            List<string> schemaColumns = tableDefinition.Columns.Keys.ToList();

            try
            {
                foreach (KeyValuePair<string, object> param in mutationParams)
                {
                    // Create Parameter and map it to column for downstream logic to utilize.
                    string paramIdentifier = MakeParamWithValue(GetParamAsColumnSystemType(param.Value.ToString(), param.Key));

                    ColumnToParam.Add(param.Key, paramIdentifier);

                    // Create a predicate for UPDATE Operation.
                    Predicate predicate = new(
                        new PredicateOperand(new Column(null, param.Key)),
                        PredicateOperation.Equal,
                        new PredicateOperand($"@{paramIdentifier}")
                    );

                    // We are guaranteed by the RequestValidator, that a primary key column is in the URL, not body.
                    // That means we must add the PK as predicate for the update request,
                    // as Update request uses Where clause to target item by PK.
                    if (primaryKeys.Contains(param.Key))
                    {
                        // For update, we don't care if it's autogenerated, we will update item based on PK.
                        // Only relevant for Insert operation.
                        if (!tableDefinition.Columns[param.Key].IsAutoGenerated)
                        {
                            // Only add PK column to insert request if not a PK.
                            InsertColumns.Add(param.Key);
                            PopulateColumnsAndParams(param.Key, param.Value);
                        }

                        // PK added as predicate for Update Operation
                        Predicates.Add(predicate);

                        // Track which columns we've acted upon,
                        // so we can add nullified remainder columns later.
                        schemaColumns.Remove(param.Key);
                    }
                    // No final else statement as invalid column for schema is caught in RequestValidation.
                    else if (schemaColumns.Contains(param.Key))
                    {
                        // Update Operation. Add since mutation param is not a PK.
                        UpdateOperations.Add(predicate);
                        schemaColumns.Remove(param.Key);

                        // Insert Operation, create record with request specified value.
                        PopulateColumnsAndParams(param.Key, param.Value);
                    }
                }

                // Process remaining columns in schemaColumns.
                AddNullifiedUnspecifiedFields(schemaColumns);
            }
            catch (ArgumentException ex)
            {
                // ArgumentException thrown from GetParamAsColumnSystemType()
                throw new DatagatewayException(
                    message: ex.Message,
                    statusCode: (int) HttpStatusCode.BadRequest,
                    subStatusCode: DatagatewayException.SubStatusCodes.BadRequest);
            }
        }

        /// <summary>
        /// For UPDATE (OVERWRITE) operation
        /// Adds result of (TableDefinition.Columns minus MutationFields) to UpdateOperations with null values
        /// There will not be any columns leftover that are PK, since they are handled in request validation.
        /// </summary>
        /// <param name="columns"></param>
        private void AddNullifiedUnspecifiedFields(List<string> leftoverSchemaColumns)
        {
            //result of adding (TableDefinition.Columns - MutationFields) to UpdateOperations
            foreach (string leftOverColumn in leftoverSchemaColumns)
            {
                Predicate predicate = new(
                    new PredicateOperand(new Column(null, leftOverColumn)),
                    PredicateOperation.Equal,
                    new PredicateOperand($"@{MakeParamWithValue(null)}")
                );

                UpdateOperations.Add(predicate);
            }
        }

        /// <summary>
        /// Populates the column name in Columns, gets created parameter
        /// and adds its value to Values.
        /// </summary>
        /// <param name="columnName">The name of the column.</param>
        /// <param name="value">The value of the column.</param>
        private void PopulateColumnsAndParams(string columnName, object value)
        {
            InsertColumns.Add(columnName);
            string paramName;

            if (value != null)
            {
                //Check parameter Dictionary/List
                paramName = ColumnToParam[columnName];
            }
            else
            {
                // This case should not arise. We have issue for this to handle nullable type columns. Issue #146.
                throw new DatagatewayException(
                    message: $"Unexpected value for column \"{columnName}\" provided.",
                    statusCode: (int)HttpStatusCode.BadRequest,
                    subStatusCode: DatagatewayException.SubStatusCodes.BadRequest);
            }

            Values.Add($"@{paramName}");
        }
    }
}
