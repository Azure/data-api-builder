// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Data.Common;
using System.Text;
using Azure.DataApiBuilder.Config.ObjectModel;
using Azure.DataApiBuilder.Core.Models;
using Microsoft.Data.SqlClient;

namespace Azure.DataApiBuilder.Core.Resolvers
{
    /// <summary>
    /// Class for building DwSql queries.
    /// </summary>
    public class DwSqlQueryBuilder : BaseSqlQueryBuilder, IQueryBuilder
    {
        private static DbCommandBuilder _builder = new SqlCommandBuilder();

        /// <inheritdoc />
        public override string QuoteIdentifier(string ident)
        {
            return _builder.QuoteIdentifier(ident);
        }

        /// <summary>
        /// Builds the sql query that will return the json result for DW.
        /// Sample: Get title of all books.
        /// SELECT COALESCE('['+STRING_AGG('{"title":"' + STRING_ESCAPE(ISNULL(title,''),'json') + '"}',', ')+']','[]')
        /// FROM (
        ///     SELECT TOP 100 [table0].[title] AS [title]
        ///     FROM [dbo].[books] AS [table0]
        ///     WHERE 1 = 1 ORDER BY [table0].[id] ASC
        ///     ) AS [table0]
        /// </summary>
        public string Build(SqlQueryStructure structure)
        {
            return BuildAsJson(structure);
        }

        /// <summary>
        /// Builds the sql query that will return the json result for the sql query.
        /// </summary>
        /// <param name="structure">Sql query structure to build query on.</param>
        /// <param name="subQueryStructure">if this is a sub query executed under outerapply.</param>
        /// <returns></returns>
        private string BuildAsJson(SqlQueryStructure structure, bool subQueryStructure = false)
        {
            string columns = GenerateColumnsAsJson(structure, subQueryStructure);
            string fromSql = $"{BuildSqlQuery(structure)}";
            string query = $"SELECT {columns}"
                + $" FROM ({fromSql}) AS {QuoteIdentifier(structure.SourceAlias)}";
            return query;
        }

        /// <summary>
        /// Build internal sql query for DW.
        /// This will generate the query that will return results in sql.
        /// Results of this query will be jsonified and returned to the user.
        /// Sample: Get title, publishers and authors of a book.
        /// SELECT TOP 100 [table0].[title] AS[title],
        /// [table1_subq].[data] AS[publishers],
        /// COALESCE('['+[table7_subq].[data]+']', '[]')) AS[authors]
        /// FROM dbo_books AS[table0]
        /// OUTER APPLY(SubQuery generated by recursive call to build function, will create the _subq tables)
        /// </summary>
        private string BuildSqlQuery(SqlQueryStructure structure)
        {
            string dataIdent = QuoteIdentifier(SqlQueryStructure.DATA_IDENT);
            StringBuilder fromSql = new();

            fromSql.Append($"{QuoteIdentifier(structure.DatabaseObject.SchemaName)}.{QuoteIdentifier(structure.DatabaseObject.Name)} " +
                             $"AS {QuoteIdentifier($"{structure.SourceAlias}")}{Build(structure.Joins)}");

            fromSql.Append(string.Join(
                    "",
                    structure.JoinQueries.Select(
                        x => $" OUTER APPLY ({BuildAsJson(x.Value, true)}) AS {QuoteIdentifier(x.Key)}({dataIdent})")));

            string predicates = JoinPredicateStrings(
                                    structure.GetDbPolicyForOperation(EntityActionOperation.Read),
                                    structure.FilterPredicates,
                                    Build(structure.Predicates),
                                    Build(structure.PaginationMetadata.PaginationPredicate));
            string columns = WrappedColumns(structure);
            string orderBy = $" ORDER BY {Build(structure.OrderByColumns)}";

            string query = $"SELECT TOP {structure.Limit()} {columns}"
                + $" FROM {fromSql}"
                + $" WHERE {predicates}"
                + orderBy;
            return query;
        }

        private static string GenerateColumnsAsJson(SqlQueryStructure structure, bool subQueryStructure = false)
        {
            string columns;
            StringBuilder stringAgg = new();
            int i = 0;
            // Iterate through all the columns and build the string_agg
            foreach (LabelledColumn column in structure.Columns)
            {
                // Generate the col value.
                bool subQueryColumn = structure.IsSubqueryColumn(column);
                string col_value = column.Label;
                string escapedLabel = column.Label.Replace("'", "''");

                // If the column is not a subquery column and is not a string, cast it to string
                if (!subQueryColumn && structure.GetColumnSystemType(column.ColumnName) != typeof(string))
                {
                    col_value = $"CAST([{col_value}] AS NVARCHAR(MAX))";

                    Type col_type = structure.GetColumnSystemType(column.ColumnName);

                    if (col_type == typeof(DateTime))
                    {
                        // need to wrap datetime in quotes to ensure correct deserialization.
                        stringAgg.Append($"N\'\"{escapedLabel}\":\"\' + ISNULL(STRING_ESCAPE({col_value},'json'),'null') + \'\"\'+");
                    }
                    else if (col_type == typeof(Boolean))
                    {
                        stringAgg.Append($"N\'\"{escapedLabel}\":\' + ISNULL(IIF({col_value} = 1, 'true', 'false'),'null')");
                    }
                    else
                    {
                        // Create json. Example: "book.id": 1 would be a sample output.
                        stringAgg.Append($"N\'\"{escapedLabel}\":\' + ISNULL(STRING_ESCAPE({col_value},'json'),'null')");
                    }
                }
                else
                {
                    // Create json. Example: "book.title": "Title" would be a sample output.
                    stringAgg.Append($"N\'\"{escapedLabel}\":\' + ISNULL(\'\"\'+STRING_ESCAPE([{col_value}],'json')+\'\"\','null')");
                }

                i++;

                // Add comma if not last column. example: {"id":"1234","name":"Big Company"}
                // the below ensures there is a comma after id but not after name.
                if (i != structure.Columns.Count)
                {
                    stringAgg.Append("+\',\'+");
                }
            }

            columns = $"STRING_AGG(\'{{\'+{stringAgg}+\'}}\',', ')";
            if (structure.IsListQuery)
            {
                // Array wrappers if we are trying to get a list of objects.
                columns = $"COALESCE(\'[\'+{columns}+\']\',\'[]\')";
            }
            else if (!subQueryStructure)
            {
                // outer apply sub queries can return null as that will be stored in the json.
                // However, for the main query, we need to return an empty string if the result is null as the sql cant read the NULL
                columns = $"COALESCE({columns},\'\')";
            }

            return columns;
        }

        /// <inheritdoc />
        public string Build(SqlInsertStructure structure)
        {
            throw new NotImplementedException("DataWarehouse Sql currently does not support inserts");
        }

        /// <inheritdoc />
        public string Build(SqlUpdateStructure structure)
        {
            throw new NotImplementedException("DataWarehouse sql currently does not support updates");
        }

        /// <inheritdoc />
        public string Build(SqlDeleteStructure structure)
        {
            throw new NotImplementedException("DataWarehouse sql currently does not support deletes");
        }

        /// <inheritdoc />
        public string Build(SqlExecuteStructure structure)
        {
            throw new NotImplementedException("DataWarehouse sql currently does not support executes");
        }

        /// <inheritdoc />
        public string Build(SqlUpsertQueryStructure structure)
        {
            throw new NotImplementedException("DataWarehouse sql currently does not support updates");
        }

        /// <summary>
        /// Add a JSON_QUERY wrapper on the column
        /// </summary>
        private string WrapSubqueryColumn(LabelledColumn column, SqlQueryStructure subquery)
        {
            string builtColumn = Build(column as Column);
            if (subquery.IsListQuery)
            {
                return $"(COALESCE({builtColumn}, '[]'))";
            }

            return $"({builtColumn})";
        }

        /// <summary>
        /// Build columns and wrap columns which represent join subqueries
        /// </summary>
        private string WrappedColumns(SqlQueryStructure structure)
        {
            return string.Join(", ",
                structure.Columns.Select(
                    c => structure.IsSubqueryColumn(c) ?
                        WrapSubqueryColumn(c, structure.JoinQueries[c.TableAlias!]) + $" AS {QuoteIdentifier(c.Label)}" :
                        Build(c)
            ));
        }

        /// <inheritdoc />
        public string BuildStoredProcedureResultDetailsQuery(string databaseObjectName)
        {
            throw new NotImplementedException("DataWarehouse sql currently does not support stored procedures");
        }

        /// <summary>
        /// Builds the query to get all the read-only columns in an DWSql table.
        /// For DWSql, the columns:
        /// 1. That have data_type of 'timestamp', or
        /// 2. are computed based on other columns,
        /// are considered as read only columns. The query combines both the types of read-only columns and returns the list.
        /// </summary>
        /// <param name="schemaOrDatabaseParamName">Param name of the schema/database.</param>
        /// <param name="tableParamName">Param name of the table.</param>
        /// <returns>String representing the query needed to get a combined list of read only columns.</returns>
        public string BuildQueryToGetReadOnlyColumns(string schemaParamName, string tableParamName)
        {
            // For 'timestamp' columns sc.is_computed = 0.
            string query = "SELECT ifsc.column_name from sys.columns as sc INNER JOIN INFORMATION_SCHEMA.COLUMNS as ifsc " +
                "ON (sc.is_computed = 1 or ifsc.data_type = 'timestamp') " +
                $"AND sc.object_id = object_id({schemaParamName}+'.'+{tableParamName}) and ifsc.table_name = {tableParamName} " +
                $"AND ifsc.table_schema = {schemaParamName} and ifsc.column_name = sc.name;";

            return query;
        }

        /// <inheritdoc/>
        public string BuildFetchEnabledTriggersQuery()
        {
            string query = "SELECT STE.type_desc FROM sys.triggers ST inner join sys.trigger_events STE " +
                "On ST.object_id = STE.object_id AND ST.parent_id = object_id(@param0 + '.' + @param1) WHERE ST.is_disabled = 0;";

            return query;
        }
    }
}
