// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Azure.DataApiBuilder.Service.Tests.SqlTests;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Azure.DataApiBuilder.Core.Resolvers;
using HotChocolate.Resolvers;
using Moq;
using HotChocolate.Execution;
using HotChocolate.Language;
using System.Collections.Generic;
using Azure.DataApiBuilder.Service.Exceptions;

namespace Azure.DataApiBuilder.Service.Tests.Unittests
{
    [TestClass]
    public abstract class NestedCreateOrderHelperUnitTests : SqlTestBase
    {
        /// <summary>
        /// Test to validate that when all the relationship fields in the source/target entity are non-autogenerated,
        /// and the input for both the source and the target entity contain the value for the relationship fields, we cannot
        /// successfully determine which entity should be considered as the referencing entity and hence,
        /// we throw an appropriate exception.
        ///
        /// Here, the relationship between entities: 'User_NonAutogenRelationshipColumn' and 'UserProfile_NonAutogenRelationshipColumn'
        /// is defined as User_NonAutogenRelationshipColumn(username) -> UserProfile_NonAutogenRelationshipColumn(username)
        /// where the field 'username' is non-autogenerated in both the entities.
        /// </summary>
        [TestMethod]
        public void ValidateIndeterministicReferencingEntityForNonAutogenRelationshipColumns()
        {
            IMiddlewareContext context = SetupMiddlewareContext();
            string sourceEntityName = "User_NonAutogenRelationshipColumn";
            string targetEntityName = "UserProfile_NonAutogenRelationshipColumn";

            // Setup column input in source entity.
            Dictionary<string, IValueNode> columnDataInSourceBody = new()
            {
                { "username", new StringValueNode("DAB") },
                { "email", new StringValueNode("dab@microsoft.com") }
            };

            // Setup column input for target entity.
            ObjectValueNode targetNodeValue = new();
            List<ObjectFieldNode> fields = new()
            {
                new ObjectFieldNode("username", "DAB"),
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture"),
                new ObjectFieldNode("userid", 1)
            };
            targetNodeValue = targetNodeValue.WithFields(fields);

            // Since the non-autogenerated relationship field 'username' is present in the input for both
            // the source and target entity, assert that we get the expected exception.
            DataApiBuilderException ex = Assert.ThrowsException<DataApiBuilderException>(() => NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue));
        }

        /// <summary>
        /// Test to validate that when all the relationship fields in the source/target entity are non-autogenerated,
        /// either the input for the source or the target entity should contain the value for the relationship fields.
        /// The entity which contains the values for all relationship fields is considered as the referenced entity, and the other
        /// entity is considered as the referencing entity.
        ///
        /// Here, the relationship between entities: 'User_NonAutogenRelationshipColumn' and 'UserProfile_NonAutogenRelationshipColumn'
        /// is defined as User_NonAutogenRelationshipColumn(username) -> UserProfile_NonAutogenRelationshipColumn(username)
        /// where the field 'username' is non-autogenerated in both the entities.
        /// </summary>
        [TestMethod]
        public void ValidateDeterministicReferencingEntityForNonAutogenRelationshipColumns()
        {
            // Test 1: The value for relationship field 'username' is present in the input for the source entity.
            IMiddlewareContext context = SetupMiddlewareContext();
            string sourceEntityName = "User_NonAutogenRelationshipColumn";
            string targetEntityName = "UserProfile_NonAutogenRelationshipColumn";

            // Setup column input in source entity.
            Dictionary<string, IValueNode> columnDataInSourceBody = new()
            {
                { "username", new StringValueNode("DAB") },
                { "email", new StringValueNode("dab@microsoft.com") }
            };

            // Setup column input in source entity.
            ObjectValueNode targetNodeValue = new();
            List<ObjectFieldNode> fields = new()
            {
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture"),
                new ObjectFieldNode("userid", 10)
            };
            targetNodeValue = targetNodeValue.WithFields(fields);

            // Get the referencing entity name. Since the source entity contained the value for relationship field,
            // it act as the referenced entity, and the target entity act as the referencing entity.
            string referencingEntityName = NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue);
            Assert.AreEqual(targetEntityName, referencingEntityName);

            // Test 2: The value for relationship field 'username' is present in the input for the target entity.
            // Setup column input in source entity.
            columnDataInSourceBody = new()
            {
                { "email", new StringValueNode("dab@microsoft.com") }
            };

            // Setup column input in target entity.
            targetNodeValue = new();
            fields = new()
            {
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture"),
                new ObjectFieldNode("userid", 10),
                new ObjectFieldNode("username", "DAB")
            };
            targetNodeValue = targetNodeValue.WithFields(fields);

            // Get the referencing entity name.
            referencingEntityName = NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue);
            // Since the target entity contained the value for relationship field,
            // it act as the referenced entity, and the source entity act as the referencing entity.
            Assert.AreEqual(sourceEntityName, referencingEntityName);
        }

        /// <summary>
        /// Test to validate that when a pair of relationship fields in the source/target entity are autogenerated,
        /// it is not possible to determine a referencing entity. This is because we cannot provide a value for insertion
        /// for an autogenerated relationship field in any of the entity.
        /// Hence, none of the entity can act as a referencing/referenced entity.
        ///
        /// Here, the relationship between entities: 'User_AutogenRelationshipColumn' and 'UserProfile_AutogenRelationshipColumn'
        /// is defined as User_AutogenRelationshipColumn(userid) -> UserProfile_AutogenRelationshipColumn(profileid)
        /// where both the relationships fields 'username' are autogenerated in the respective entities.
        /// </summary>
        [TestMethod]
        public void ValidateIndeterministicReferencingEntityForAutogenRelationshipColumns()
        {
            IMiddlewareContext context = SetupMiddlewareContext();
            string sourceEntityName = "User_AutogenRelationshipColumn";
            string targetEntityName = "UserProfile_AutogenRelationshipColumn";

            // Setup column input for source entity.
            Dictionary<string, IValueNode> columnDataInSourceBody = new()
            {
                { "username", new StringValueNode("DAB") },
                { "email", new StringValueNode("dab@microsoft.com") }
            };

            // Setup column input for target entity.
            ObjectValueNode targetNodeValue = new();
            List<ObjectFieldNode> fields = new()
            {
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture"),
                new ObjectFieldNode("userid", 1)
            };

            targetNodeValue = targetNodeValue.WithFields(fields);

            // Since the relationship fields in both the entities are autogenerated, assert that we get the expected exception.
            DataApiBuilderException ex = Assert.ThrowsException<DataApiBuilderException>(() => NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue));
        }

        /// <summary>
        /// Test to validate that when a relationship field in one of the entity is autogenerated, then if the value
        /// of atleast one (or more) other non-autogenerated fields is specified in the input for the other entity, it is not possible
        /// to successfully determine a referencing entity. This is because neither of the entity on its own, will contain values for
        /// all the columns required to do insertion and act as a referenced entity. Hence, we throw an appropriate exception.
        ///
        /// Here, the relationship between entities: 'User_AutogenToNonAutogenRelationshipColumn' and
        /// 'UserProfile_NonAutogenToAutogenRelationshipColumn' is defined as:
        /// User_AutogenToNonAutogenRelationshipColumn(userid, username) -> UserProfile_NonAutogenToAutogenRelationshipColumn(userid, username)
        /// where both the relationships fields User_AutogenToNonAutogenRelationshipColumn.userid is an autogenerated field while all other
        /// relationship fields are non-autogenerated.
        /// </summary>
        [TestMethod]
        public void ValidateIndeterministicReferencingEntityForAutogenAndNonAutogenRelationshipColumns()
        {
            // Test 1
            IMiddlewareContext context = SetupMiddlewareContext();
            string sourceEntityName = "User_AutogenToNonAutogenRelationshipColumn";
            string targetEntityName = "UserProfile_NonAutogenToAutogenRelationshipColumn";

            // Setup column input in source entity.
            Dictionary<string, IValueNode> columnDataInSourceBody = new()
            {
                { "email", new StringValueNode("dab@microsoft.com") }
            };

            // Setup column input in target entity.
            ObjectValueNode targetNodeValue = new();
            List<ObjectFieldNode> fields = new()
            {
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture"),
                new ObjectFieldNode("username", "DAB")
            };
            targetNodeValue = targetNodeValue.WithFields(fields);

            // Since the source entity contains an autogenerated relationship field (userid) and the input for target entity
            // contains the relationship field 'username' in it, assert that we get the expected exception.
            DataApiBuilderException ex = Assert.ThrowsException<DataApiBuilderException>(() => NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue));
        }

        /// <summary>
        /// Test to validate that when a relationship field in one of the entity is autogenerated, then if the value
        /// of all other non-autogenerated fields is also specified in the input for the same entity, we successfully determine that
        /// the other entity will act as the referencing entity. This is because the first entity, on its own, will contain values for
        /// all the columns required to do insertion and act as a referenced entity.
        ///
        /// Here, the relationship between entities: 'User_AutogenToNonAutogenRelationshipColumn' and
        /// 'UserProfile_NonAutogenToAutogenRelationshipColumn' is defined as:
        /// User_AutogenToNonAutogenRelationshipColumn(userid, username) -> UserProfile_NonAutogenToAutogenRelationshipColumn(userid, username)
        /// where both the relationships fields User_AutogenToNonAutogenRelationshipColumn.userid is an autogenerated field while all other
        /// relationship fields are non-autogenerated.
        /// </summary>
        [TestMethod]
        public void ValidateDeterministicReferencingEntityForAutogenAndNonAutogenRelationshipColumns()
        {
            // Test 1
            IMiddlewareContext context = SetupMiddlewareContext();
            string sourceEntityName = "User_AutogenToNonAutogenRelationshipColumn";
            string targetEntityName = "UserProfile_NonAutogenToAutogenRelationshipColumn";

            // Setup column input in source entity.
            Dictionary<string, IValueNode> columnDataInSourceBody = new()
            {
                { "email", new StringValueNode("dab@microsoft.com") },
                { "username", new StringValueNode("DAB") }
            };

            // Setup column input in target entity.
            ObjectValueNode targetNodeValue = new();
            List<ObjectFieldNode> fields = new()
            {
                new ObjectFieldNode("profilepictureurl", "dab/profilepicture")
            };

            targetNodeValue = targetNodeValue.WithFields(fields);

            string referencingEntityName = NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: columnDataInSourceBody,
                targetNodeValue: targetNodeValue);

            Assert.AreEqual("UserProfile_NonAutogenToAutogenRelationshipColumn", referencingEntityName);
        }

        private static IMiddlewareContext SetupMiddlewareContext()
        {
            Mock<IMiddlewareContext> context = new();
            Mock<IVariableValueCollection> variables = new();
            context.Setup(x => x.Variables).Returns(variables.Object);
            return context.Object;
        }

        /// <summary>
        /// Test to validate that when an FK constraint exists between the entities, we can determine which of the entity
        /// acts as the referencing entity based on the database metadata that we collect at the startup.
        /// The entity which holds the foreign key reference acts as the referencing entity.
        /// </summary>
        [TestMethod]
        public void ValidateReferencingEntityBasedOnEntityMetadata()
        {
            // Validate that for a relationship of cardinality N:1 between Review - Book where FK constraint
            // exists from Review -> Book, irrespective of which entity is the source in nested create operation,
            // we successfully determine at the startup, that Review is the referencing entity.

            // Review is the source entity.
            ValidateReferencingEntityForRelationship(
                sourceEntityName: "Review",
                targetEntityName: "Book",
                expectedReferencingEntityName: "Review" );

            // Book is the source entity.
            ValidateReferencingEntityForRelationship(
                sourceEntityName: "Book",
                targetEntityName: "Review",
                expectedReferencingEntityName: "Review");

            // Validate that for a relationship of cardinality 1:N between Book - Publisher where FK constraint
            // exists from Book -> Publisher,irrespective of which entity is the source in nested create operation,
            // we successfully determine at the startup, that Book is the referencing entity.

            // Book is the source entity.
            ValidateReferencingEntityForRelationship(
                sourceEntityName: "Book",
                targetEntityName: "Publisher",
                expectedReferencingEntityName: "Book");

            // Publisher is the source entity.
            ValidateReferencingEntityForRelationship(
                sourceEntityName: "Publisher",
                targetEntityName: "Book",
                expectedReferencingEntityName: "Book");

            // Validate that for a relationship of cardinality 1:1 between Stock - stocks_price where FK constraint
            // exists from stocks_price -> Stock, we successfully determine at the startup, that stocks_price is the
            // referencing entity.
            // Stock is the source entity.
            ValidateReferencingEntityForRelationship(
                sourceEntityName: "Stock",
                targetEntityName: "stocks_price",
                expectedReferencingEntityName: "stocks_price");
        }

        private static void ValidateReferencingEntityForRelationship(
            string sourceEntityName,
            string targetEntityName,
            string expectedReferencingEntityName)
        {
            // Setup mock IMiddlewareContext.
            IMiddlewareContext context = SetupMiddlewareContext();

            // Get the referencing entity.
            string actualReferencingEntityName = NestedCreateOrderHelper.GetReferencingEntityName(
                context: context,
                sourceEntityName: sourceEntityName,
                targetEntityName: targetEntityName,
                metadataProvider: _sqlMetadataProvider,
                columnDataInSourceBody: new(),
                targetNodeValue: null);
            Assert.AreEqual(expectedReferencingEntityName, actualReferencingEntityName);
        }
    }
}
