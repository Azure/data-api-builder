<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HotChocolate.Validation</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:HotChocolate.Validation.DocumentValidator">
            <summary>
            The default document validator implementation.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.DocumentValidator.#ctor(HotChocolate.Validation.DocumentValidatorContextPool,System.Collections.Generic.IEnumerable{HotChocolate.Validation.IDocumentValidatorRule})">
            <summary>
            Creates a new instance of <see cref="T:HotChocolate.Validation.DocumentValidator"/>.
            </summary>
            <param name="contextPool">
            The document validator context pool.
            </param>
            <param name="rules">
            The validation rules.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:HotChocolate.Validation.DocumentValidator.HasDynamicRules">
            <inheritdoc />
        </member>
        <member name="M:HotChocolate.Validation.DocumentValidator.Validate(HotChocolate.ISchema,HotChocolate.Language.DocumentNode)">
            <inheritdoc />
        </member>
        <member name="M:HotChocolate.Validation.DocumentValidator.Validate(HotChocolate.ISchema,HotChocolate.Language.DocumentNode,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:HotChocolate.Validation.FieldInfo">
            <summary>
            The validation field info provides access to the field node and the type
            information of the referenced field.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.FieldInfo.#ctor(HotChocolate.Types.IType,HotChocolate.Types.IType,HotChocolate.Language.FieldNode)">
            <summary>
            Initializes a new instance of <see cref="T:HotChocolate.Validation.FieldInfo"/>
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.FieldInfo.ResponseName">
            <summary>
            Gets the response name.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.FieldInfo.DeclaringType">
            <summary>
            Gets the declaring type.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.FieldInfo.Type">
            <summary>
            Gets the field's return type.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.FieldInfo.Field">
            <summary>
            Gets the field selection.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.IDocumentValidator">
            <summary>
            The document validator will analyze if the GraphQL request document is valid
            in the current schema context.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidator.HasDynamicRules">
            <summary>
            Specifies that the validator needs to be invoked for 
            every request and that the validation result cannot be 
            fully cached.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.IDocumentValidator.Validate(HotChocolate.ISchema,HotChocolate.Language.DocumentNode)">
            <summary>
            Validates the current document against the current schema context.
            </summary>
            <param name="schema">
            The schema.
            </param>
            <param name="document">
            The document to validate.
            </param>
            <returns>
            The result of the document validation.
            </returns>
        </member>
        <member name="M:HotChocolate.Validation.IDocumentValidator.Validate(HotChocolate.ISchema,HotChocolate.Language.DocumentNode,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Validates the current document against the current schema context.
            </summary>
            <param name="schema">
            The schema.
            </param>
            <param name="document">
            The document to validate.
            </param>
            <param name="contextData">
            Arbitrary execution context data that can be used during the document validation.
            </param>
            <param name="onlyNonCacheable">
            Defines that only rules shall be evaluated that are not cacheable.
            </param>
            <returns>
            The result of the document validation.
            </returns>
        </member>
        <member name="T:HotChocolate.Validation.IDocumentValidatorContext">
            <summary>
            This interface represents the document validation context that can
            be used by validation visitors to build up state.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Schema">
            <summary>
            Gets the schema on which the validation is executed.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.NonNullString">
            <summary>
            Gets a non-null string type.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Path">
            <summary>
            The current visitation path of syntax nodes.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.SelectionSets">
            <summary>
            The current visitation path of selection sets.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.FieldSets">
            <summary>
            A dictionary to store field infos per selection set.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.FieldTuples">
            <summary>
            A set of field tuples.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.VisitedFragments">
            <summary>
            Gets a set of already visited fragment names.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.VariableValues">
            <summary>
            Gets the raw variable values.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Variables">
            <summary>
            Gets a map exposing the variable definitions by name.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Fragments">
            <summary>
            Gets a map exposing the fragment definitions by name.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Used">
            <summary>
            Gets a set to track usages of arbitrary names.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Unused">
            <summary>
            Gets a set to track which names are not used.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Declared">
            <summary>
            Gets a set which names are declared.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Names">
            <summary>
            Gets a set to track which names.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Types">
            <summary>
            The current visitation path of types.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Directives">
            <summary>
            The current visitation path of directive types.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.OutputFields">
            <summary>
            The current visitation path of output fields.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Fields">
            <summary>
            The current visitation path of selections.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.InputFields">
            <summary>
            The current visitation path of input fields.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Errors">
            <summary>
            A list to track validation errors that occurred during the visitation.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Count">
            <summary>
            Gets ors sets a single counter.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.Max">
            <summary>
            Gets ors sets a single max value counter.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.List">
            <summary>
            Gets a list of objects that can be used by validation rules.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.UnexpectedErrorsDetected">
            <summary>
            Defines that a visitation has found an unexpected error
            that is no concern of the current validation rule.
            If no other error is found by any validation this will
            lead to an unexpected validation error.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorContext.ContextData">
            <summary>
            A map to store arbitrary visitor data.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.IDocumentValidatorContext.RentFieldInfoList">
            <summary>
            Rents a list of field infos.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.IDocumentValidatorFactory">
            <summary>
            The <see cref="T:HotChocolate.Validation.IDocumentValidatorFactory" /> can create a validator for a specified schema.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.IDocumentValidatorFactory.CreateValidator(HotChocolate.NameString)">
            <summary>
            Creates a GraphQL document validator for the specified schema.
            </summary>
            <param name="schemaName">
            The name of the schema for which a document validator shall be created.
            </param>
            <returns>
            Returns a the document validator for the specified schema.
            </returns>
        </member>
        <member name="T:HotChocolate.Validation.IDocumentValidatorRule">
            <summary>
            A validation rule inspects a GraphQL document for a certain set of errors.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.IDocumentValidatorRule.IsCacheable">
            <summary>
            Defines if the result of this rule can be cached and reused on consecutive
            validations of the same GraphQL request document.
            </summary>
        </member>
        <member name="M:HotChocolate.Validation.IDocumentValidatorRule.Validate(HotChocolate.Validation.IDocumentValidatorContext,HotChocolate.Language.DocumentNode)">
            <summary>
            Validates the document.
            </summary>
            <param name="context">
            The validation context.
            </param>
            <param name="document">
            The GraphQL document that shall be inspected.
            </param>
        </member>
        <member name="P:HotChocolate.Validation.Options.IMaxExecutionDepthOptionsAccessor.MaxAllowedExecutionDepth">
            <summary>
            Gets the maximum allowed depth of a query. The default value is
            <see langword="null"/>. The minimum allowed value is <c>1</c>.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.Options.IValidationBuilder">
            <summary>
            A builder for configuring the max complexity rule.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.Options.IValidationBuilder.Name">
            <summary>
            Gets the name of the schema for which this rule is configure.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.Options.IValidationBuilder.Services">
            <summary>
            Gets the application service collection.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.Options.ValidationOptions">
            <summary>
            The validation options.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.Options.ValidationOptions.Rules">
            <summary>
            Gets the document rules of the validation.
            </summary>
        </member>
        <member name="P:HotChocolate.Validation.Options.ValidationOptions.MaxAllowedExecutionDepth">
            <summary>
            Gets the maximum allowed depth of a query. The default value is
            <see langword="null"/>. The minimum allowed value is <c>1</c>.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.ArgumentVisitor">
             <summary>
             Every argument provided to a field or directive must be defined
             in the set of possible arguments of that field or directive.
            
             http://facebook.github.io/graphql/June2018/#sec-Argument-Names
            
             AND
            
             Fields and directives treat arguments as a mapping of argument name
             to value.
            
             More than one argument with the same name in an argument set
             is ambiguous and invalid.
            
             http://facebook.github.io/graphql/June2018/#sec-Argument-Uniqueness
            
             AND
            
             Arguments can be required. An argument is required if the argument
             type is non‐null and does not have a default value. Otherwise,
             the argument is optional.
            
             http://facebook.github.io/graphql/June2018/#sec-Required-Arguments
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.DirectiveVisitor">
             <summary>
             GraphQL servers define what directives they support.
             For each usage of a directive, the directive must be available
             on that server.
            
             http://spec.graphql.org/June2018/#sec-Directives-Are-Defined
            
             AND
            
             GraphQL servers define what directives they support and where they
             support them.
            
             For each usage of a directive, the directive must be used in a
             location that the server has declared support for.
            
             http://spec.graphql.org/June2018/#sec-Directives-Are-In-Valid-Locations
            
             AND
            
             Directives are used to describe some metadata or behavioral change on
             the definition they apply to.
            
             When more than one directive of the
             same name is used, the expected metadata or behavior becomes ambiguous,
             therefore only one of each directive is allowed per location.
            
             http://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.DocumentRule">
             <summary>
             GraphQL execution will only consider the executable definitions
             Operation and Fragment.
            
             Type system definitions and extensions are not executable,
             and are not considered during execution.
            
             To avoid ambiguity, a document containing TypeSystemDefinition
             is invalid for execution.
            
             GraphQL documents not intended to be directly executed may
             include TypeSystemDefinition.
            
             http://spec.graphql.org/June2018/#sec-Executable-Definitions
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.FieldVisitor">
             <summary>
             The target field of a field selection must be defined on the scoped
             type of the selection set. There are no limitations on alias names.
            
             http://spec.graphql.org/June2018/#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types
            
             AND
            
             Field selections on scalars or enums are never allowed,
             because they are the leaf nodes of any GraphQL query.
            
             Conversely the leaf field selections of GraphQL queries
             must be of type scalar or enum. Leaf selections on objects,
             interfaces, and unions without subfields are disallowed.
            
             http://spec.graphql.org/June2018/#sec-Leaf-Field-Selections
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.FragmentVisitor">
             <summary>
             Fragment definitions are referenced in fragment spreads by name.
             To avoid ambiguity, each fragment’s name must be unique within a
             document.
            
             http://spec.graphql.org/June2018/#sec-Fragment-Name-Uniqueness
            
             AND
            
             Defined fragments must be used within a document.
            
             http://spec.graphql.org/June2018/#sec-Fragments-Must-Be-Used
            
             AND
            
             Fragments can only be declared on unions, interfaces, and objects.
             They are invalid on scalars.
             They can only be applied on non‐leaf fields.
             This rule applies to both inline and named fragments.
            
             http://spec.graphql.org/June2018/#sec-Fragments-On-Composite-Types
            
             AND
            
             Fragments are declared on a type and will only apply when the
             runtime object type matches the type condition.
            
             They also are spread within the context of a parent type.
            
             A fragment spread is only valid if its type condition could ever
             apply within the parent type.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spread-is-possible
            
             AND
            
             Named fragment spreads must refer to fragments defined within the
             document.
            
             It is a validation error if the target of a spread is not defined.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spread-target-defined
            
             AND
            
             The graph of fragment spreads must not form any cycles including
             spreading itself. Otherwise an operation could infinitely spread or
             infinitely execute on cycles in the underlying data.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spreads-must-not-form-cycles
            
             AND
            
             Fragments must be specified on types that exist in the schema.
             This applies for both named and inline fragments.
             If they are not defined in the schema, the query does not validate.
            
             http://spec.graphql.org/June2018/#sec-Fragment-Spread-Type-Existence
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.IntrospectionVisitor">
            <summary>
            Validates if introspection is allowed.
            </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.OperationVisitor">
             <summary>
             GraphQL allows a short‐hand form for defining query operations
             when only that one operation exists in the document.
            
             http://spec.graphql.org/June2018/#sec-Lone-Anonymous-Operation
            
             AND
            
             Each named operation definition must be unique within a document
             when referred to by its name.
            
             http://spec.graphql.org/June2018/#sec-Operation-Name-Uniqueness
            
             AND
            
             Subscription operations must have exactly one root field.
            
             http://spec.graphql.org/June2018/#sec-Single-root-field
             </summary>
             <remarks>
             http://spec.graphql.org/draft/#sec-Validation.Operations
             </remarks>
        </member>
        <member name="T:HotChocolate.Validation.Rules.ValueVisitor">
             <summary>
             Every input field provided in an input object value must be defined in
             the set of possible fields of that input object’s expected type.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Field-Names
            
             AND
            
             Input objects must not contain more than one field of the same name,
             otherwise an ambiguity would exist which includes an ignored portion
             of syntax.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Field-Uniqueness
            
             AND
            
             Input object fields may be required. Much like a field may have
             required arguments, an input object may have required fields.
            
             An input field is required if it has a non‐null type and does not have
             a default value. Otherwise, the input object field is optional.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Required-Fields
            
             AND
            
             Literal values must be compatible with the type expected in the position
             they are found as per the coercion rules defined in the Type System
             chapter.
            
             http://spec.graphql.org/June2018/#sec-Values-of-Correct-Type
            
             AND
            
             Oneof Input Objects require that exactly one field must be supplied and that
             field must not be {null}.
            
             DRAFT: https://github.com/graphql/graphql-spec/pull/825
             </summary>
        </member>
        <member name="T:HotChocolate.Validation.Rules.VariableVisitor">
             <summary>
             If any operation defines more than one variable with the same name,
             it is ambiguous and invalid. It is invalid even if the type of the
             duplicate variable is the same.
            
             http://spec.graphql.org/June2018/#sec-Validation.Variables
            
             AND
            
             Variables can only be input types. Objects,
             unions, and interfaces cannot be used as inputs.
            
             http://spec.graphql.org/June2018/#sec-Variables-Are-Input-Types
            
             AND
            
             All variables defined by an operation must be used in that operation
             or a fragment transitively included by that operation.
            
             Unused variables cause a validation error.
            
             http://spec.graphql.org/June2018/#sec-All-Variables-Used
            
             AND
            
             Variables are scoped on a per‐operation basis. That means that
             any variable used within the context of an operation must be defined
             at the top level of that operation
            
             http://spec.graphql.org/June2018/#sec-All-Variable-Uses-Defined
            
             AND
            
             Variable usages must be compatible with the arguments
             they are passed to.
            
             Validation failures occur when variables are used in the context
             of types that are complete mismatches, or if a nullable type in a
              variable is passed to a non‐null argument type.
            
             http://spec.graphql.org/June2018/#sec-All-Variable-Usages-are-Allowed
             </summary>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions">
            <summary>
            Extension methods for configuring an <see cref="T:HotChocolate.Validation.Options.IValidationBuilder"/>
            </summary>
            <summary>
            Extension methods for configuring an <see cref="T:HotChocolate.Validation.Options.IValidationBuilder"/>
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddArgumentRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             Every argument provided to a field or directive must be defined
             in the set of possible arguments of that field or directive.
            
             http://spec.graphql.org/June2018/#sec-Argument-Names
            
             AND
            
             Fields and directives treat arguments as a mapping of argument name
             to value.
            
             More than one argument with the same name in an argument set
             is ambiguous and invalid.
            
             http://spec.graphql.org/June2018/#sec-Argument-Uniqueness
            
             AND
            
             Arguments can be required. An argument is required if the argument
             type is non‐null and does not have a default value. Otherwise,
             the argument is optional.
            
             http://spec.graphql.org/June2018/#sec-Required-Arguments
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddDirectiveRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             GraphQL servers define what directives they support.
             For each usage of a directive, the directive must be available
             on that server.
            
             http://spec.graphql.org/June2018/#sec-Directives-Are-Defined
            
             AND
            
             GraphQL servers define what directives they support and where they
             support them.
            
             For each usage of a directive, the directive must be used in a
             location that the server has declared support for.
            
             http://spec.graphql.org/June2018/#sec-Directives-Are-In-Valid-Locations
            
             AND
            
             Directives are used to describe some metadata or behavioral change on
             the definition they apply to.
            
             When more than one directive of the
             same name is used, the expected metadata or behavior becomes ambiguous,
             therefore only one of each directive is allowed per location.
            
             http://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddDocumentRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             GraphQL execution will only consider the executable definitions
             Operation and Fragment.
            
             Type system definitions and extensions are not executable,
             and are not considered during execution.
            
             To avoid ambiguity, a document containing TypeSystemDefinition
             is invalid for execution.
            
             GraphQL documents not intended to be directly executed may
             include TypeSystemDefinition.
            
             http://spec.graphql.org/June2018/#sec-Executable-Definitions
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddFieldRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             The target field of a field selection must be defined on the scoped
             type of the selection set. There are no limitations on alias names.
            
             http://spec.graphql.org/June2018/#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types
            
             AND
            
             Field selections on scalars or enums are never allowed,
             because they are the leaf nodes of any GraphQL query.
            
             Conversely the leaf field selections of GraphQL queries
             must be of type scalar or enum. Leaf selections on objects,
             interfaces, and unions without subfields are disallowed.
            
             http://spec.graphql.org/June2018/#sec-Leaf-Field-Selections
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddFragmentRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             Fragment definitions are referenced in fragment spreads by name.
             To avoid ambiguity, each fragment’s name must be unique within a
             document.
            
             http://spec.graphql.org/June2018/#sec-Fragment-Name-Uniqueness
            
             AND
            
             Defined fragments must be used within a document.
            
             http://spec.graphql.org/June2018/#sec-Fragments-Must-Be-Used
            
             AND
            
             Fragments can only be declared on unions, interfaces, and objects.
             They are invalid on scalars.
             They can only be applied on non‐leaf fields.
             This rule applies to both inline and named fragments.
            
             http://spec.graphql.org/June2018/#sec-Fragments-On-Composite-Types
            
             AND
            
             Fragments are declared on a type and will only apply when the
             runtime object type matches the type condition.
            
             They also are spread within the context of a parent type.
            
             A fragment spread is only valid if its type condition could ever
             apply within the parent type.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spread-is-possible
            
             AND
            
             Named fragment spreads must refer to fragments defined within the
             document.
            
             It is a validation error if the target of a spread is not defined.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spread-target-defined
            
             AND
            
             The graph of fragment spreads must not form any cycles including
             spreading itself. Otherwise an operation could infinitely spread or
             infinitely execute on cycles in the underlying data.
            
             http://spec.graphql.org/June2018/#sec-Fragment-spreads-must-not-form-cycles
            
             AND
            
             Fragments must be specified on types that exist in the schema.
             This applies for both named and inline fragments.
             If they are not defined in the schema, the query does not validate.
            
             http://spec.graphql.org/June2018/#sec-Fragment-Spread-Type-Existence
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddValueRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             Every input field provided in an input object value must be defined in
             the set of possible fields of that input object’s expected type.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Field-Names
            
             AND
            
             Input objects must not contain more than one field of the same name,
             otherwise an ambiguity would exist which includes an ignored portion
             of syntax.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Field-Uniqueness
            
             AND
            
             Input object fields may be required. Much like a field may have
             required arguments, an input object may have required fields.
            
             An input field is required if it has a non‐null type and does not have
             a default value. Otherwise, the input object field is optional.
            
             http://spec.graphql.org/June2018/#sec-Input-Object-Required-Fields
            
             AND
            
             Literal values must be compatible with the type expected in the position
             they are found as per the coercion rules defined in the Type System
             chapter.
            
             http://spec.graphql.org/June2018/#sec-Values-of-Correct-Type
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddVariableRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             If any operation defines more than one variable with the same name,
             it is ambiguous and invalid. It is invalid even if the type of the
             duplicate variable is the same.
            
             http://spec.graphql.org/June2018/#sec-Validation.Variables
            
             AND
            
             Variables can only be input types. Objects,
             unions, and interfaces cannot be used as inputs.
            
             http://spec.graphql.org/June2018/#sec-Variables-Are-Input-Types
            
             AND
            
             All variables defined by an operation must be used in that operation
             or a fragment transitively included by that operation.
            
             Unused variables cause a validation error.
            
             http://spec.graphql.org/June2018/#sec-All-Variables-Used
            
             AND
            
             Variables are scoped on a per‐operation basis. That means that
             any variable used within the context of an operation must be defined
             at the top level of that operation
            
             http://spec.graphql.org/June2018/#sec-All-Variable-Uses-Defined
            
             AND
            
             Variable usages must be compatible with the arguments
             they are passed to.
            
             Validation failures occur when variables are used in the context
             of types that are complete mismatches, or if a nullable type in a
              variable is passed to a non‐null argument type.
            
             http://spec.graphql.org/June2018/#sec-All-Variable-Usages-are-Allowed
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddOperationRules(HotChocolate.Validation.Options.IValidationBuilder)">
             <summary>
             GraphQL allows a short‐hand form for defining query operations
             when only that one operation exists in the document.
            
             http://spec.graphql.org/June2018/#sec-Lone-Anonymous-Operation
            
             AND
            
             Each named operation definition must be unique within a document
             when referred to by its name.
            
             http://spec.graphql.org/June2018/#sec-Operation-Name-Uniqueness
            
             AND
            
             Subscription operations must have exactly one root field.
            
             http://spec.graphql.org/June2018/#sec-Single-root-field
             </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.AddIntrospectionAllowedRule(HotChocolate.Validation.Options.IValidationBuilder)">
            <summary>
            Adds a validation rule that only allows requests to use `__schema` or `__type`
            if the request carries an introspection allowed flag.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.ConfigureValidation(HotChocolate.Validation.Options.IValidationBuilder,System.Action{HotChocolate.Validation.Options.ValidationOptionsModifiers})">
            <summary>
            Configures the GraphQL request validation that will be used to validate
            incoming GraphQL requests.
            </summary>
            <param name="builder">
            The <see cref="T:HotChocolate.Validation.Options.IValidationBuilder"/>.
            </param>
            <param name="configure">
            A delegate that is used to configure the <see cref="T:HotChocolate.Validation.Options.ValidationOptions"/>.
            </param>
            <returns>
            An <see cref="T:HotChocolate.Validation.Options.IValidationBuilder"/> that can be used to configure
            the GraphQL request validation.
            </returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.ConfigureValidation(HotChocolate.Validation.Options.IValidationBuilder,System.Action{System.IServiceProvider,HotChocolate.Validation.Options.ValidationOptionsModifiers})">
            <summary>
            Configures the GraphQL request validation that will be used to validate
            incoming GraphQL requests.
            </summary>
            <param name="builder">
            The <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>.
            </param>
            <param name="configureClient">
            A delegate that is used to configure the <see cref="T:HotChocolate.Validation.Options.ValidationOptions"/>.
            </param>
            <returns>
            An <see cref="T:HotChocolate.Validation.Options.IValidationBuilder"/> that can be used to configure
            the GraphQL request validation.
            </returns>
            <remarks>
            The <see cref="T:System.IServiceProvider"/> provided to <paramref name="configureClient"/>
            will be the application's root service provider instance.
            </remarks>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.HotChocolateValidationBuilderExtensions.SetAllowedExecutionDepth(HotChocolate.Validation.Options.IValidationBuilder,System.Int32)">
            <summary>
            Sets the maximum allowed depth of a query. The default
            value is <see langword="null"/>. The minimum allowed value is
            <c>1</c>.
            </summary>
        </member>
    </members>
</doc>
